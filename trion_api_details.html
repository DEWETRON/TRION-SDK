

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>TRION API in Depth &mdash; TRION SDK  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="TRION API XML Documents" href="trion_api_xml.html" />
    <link rel="prev" title="TRION API C Interface" href="trion_api_c_interface.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> TRION SDK
          

          
            
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="trion_introduction.html">Introduction to TRION Measurement Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="trion_system_overview.html">TRION and TRIONet System Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="trion_sdk_build_instructions.html">TRION SDK Build Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="trion_sdk_minimal_example.html">TRION SDK Minimal Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="trion_api_c_interface.html">TRION API C Interface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">TRION API in Depth</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#typical-application-sequence">Typical Application Sequence</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#loading-api">Loading API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initializing-the-api">Initializing the API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logical-board-open">Logical Board-Open</a></li>
<li class="toctree-l3"><a class="reference internal" href="#retrieve-xml-information">Retrieve XML-Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#putting-the-board-into-a-defined-initial-state">Putting the Board into a defined initial state</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#board-reset">Board-Reset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#load-last-configuration">Load Last Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#load-a-specific-configuration">Load a Specific Configuration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#setting-up-the-logical-configuration">Setting up the Logical Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applying-the-configuration-to-the-actual-hardware">Applying the Configuration to the actual Hardware</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-up-the-acquisition-meta-information">Setting up the Acquisition Meta-Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#acquisition-phase">Acquisition-Phase</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unloading-the-api">Unloading the API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#preprocessor-defines">Preprocessor Defines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#build-x64">BUILD_X64</a></li>
<li class="toctree-l3"><a class="reference internal" href="#build-x86">BUILD_X86</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#acquisition-ring-buffer">Acquisition Ring buffer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#scan-and-scan-size">Scan and Scan Size</a></li>
<li class="toctree-l3"><a class="reference internal" href="#block-and-block-size">Block and Block Size</a></li>
<li class="toctree-l3"><a class="reference internal" href="#block-count">Block Count</a></li>
<li class="toctree-l3"><a class="reference internal" href="#total-buffer-size">Total Buffer Size</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#synchronous-data-channels">Synchronous Data Channels</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#buffer-setup-and-buffer-ownership">Buffer Setup and Buffer Ownership</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buffer-readout-from-application-point-of-view">Buffer Readout from Application Point of View</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scan-layout">Scan Layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scan-descriptor-structure">Scan Descriptor Structure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynchronous-data-channels">Asynchronous Data channels</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#types-of-supported-asynchronous-channels">Types of supported Asynchronous Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#acquisition-of-asynchronous-channels">Acquisition of Asynchronous Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Buffer Setup and Buffer Ownership</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Buffer Readout from Application Point of View</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#directories-and-files">Directories and Files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dewetron-trion">Dewetron/Trion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dewetron-trion-systemxml">Dewetron/Trion/SystemXML</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dewetron-trion-logfiles">Dewetron/Trion/LogFiles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dewetron-trion-backup">Dewetron/Trion/Backup</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trion_api_xml.html">TRION API XML Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="trion_api_command_glossary.html">TRION API Command Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="trion_api_teds.html">TEDS Interface</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">TRION SDK</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>TRION API in Depth</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="trion-api-in-depth">
<h1>TRION API in Depth<a class="headerlink" href="#trion-api-in-depth" title="Permalink to this headline">¶</a></h1>
<div class="section" id="typical-application-sequence">
<h2>Typical Application Sequence<a class="headerlink" href="#typical-application-sequence" title="Permalink to this headline">¶</a></h2>
<p>Some of the steps shown are optional and thus will be marked indicating
this fact. Each step will be explained with a few sentences.</p>
<div class="figure align-center" id="id3">
<img alt="_images/measurement_sequence.png" src="_images/measurement_sequence.png" />
<p class="caption"><span class="caption-text">Typical API setup and measurement sequence</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="loading-api">
<h3>Loading API<a class="headerlink" href="#loading-api" title="Permalink to this headline">¶</a></h3>
<p>Requirement: Mandatory</p>
<p>Loading the API into the process memory space.</p>
</div>
<div class="section" id="initializing-the-api">
<h3>Initializing the API<a class="headerlink" href="#initializing-the-api" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">DeweDriverInit</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">nNumOfboards</span> <span class="p">);</span>
</pre></div>
</div>
<p>Requirement: Mandatory</p>
<ul class="simple">
<li><p>Initialize the internal states of the API</p></li>
<li><p>Enumerate available hardware (boards and enclosures)</p></li>
<li><p>Extract and generate the baseline XML-Information for the found
hardware</p></li>
</ul>
<p>This step may be called several times. Only the first call will actually
perform any action. All subsequent calls will notice that initialization
already has been performed within this process and therefore omit
further actions.</p>
<p>It is not necessary to keep the Initialize/DeInitialize – calls
balanced.</p>
</div>
<div class="section" id="logical-board-open">
<h3>Logical Board-Open<a class="headerlink" href="#logical-board-open" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">DeweSetParm_i32</span><span class="p">(</span> <span class="n">nBoardNo</span><span class="p">,</span> <span class="n">CMD_OPEN_BOARD</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
<span class="kt">int</span> <span class="nf">DeweSetParm_i64</span><span class="p">(</span> <span class="n">nBoardNo</span><span class="p">,</span> <span class="n">CMD_OPEN_BOARD</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</div>
<p>Requirement: Mandatory</p>
<p>Board open has to be called, for each board that will be operated during
the API usage.</p>
<ul class="simple">
<li><p>Generates detailed XML-Information about the hardware</p></li>
<li><p>Basic hardware initialization</p></li>
</ul>
<p>To open all boards CMD_OPEN_BOARD_ALL can be used:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">DeweSetParm_i32</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CMD_OPEN_BOARD_ALL</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</div>
<p>This is faster for systems with many boards installed.</p>
</div>
<div class="section" id="retrieve-xml-information">
<h3>Retrieve XML-Information<a class="headerlink" href="#retrieve-xml-information" title="Permalink to this headline">¶</a></h3>
<p>Requirement: Optional but recommended</p>
<p>For each board a descriptive XML-File can be retrieved (BoardX_Properties.xml).
This XML-File holds all valid configuration information for this specific type
of board. This file serves as documentation about the board capabilities.
So by looking at the specific XML-File it is obvious what configuration
settings are valid on which properties.</p>
<p>The XML properties can either be retrieved as a string or can be written
to a file.</p>
<p>While retrieving the description as a string is usually faster, dumping
the file to disk may help in understanding the concepts.</p>
<p>To retrieve the XML-description into a buffer for application internal
processing:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">DeweGetParamstr</span><span class="p">(</span> <span class="s">&quot;BoardID0&quot;</span><span class="p">,</span> <span class="s">&quot;BoardProperties&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1024</span> <span class="p">);</span>
</pre></div>
</div>
<p>To request the XML-description as a physical file on the hard-disk:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">filename</span><span class="o">=</span><span class="s">&quot;C:\Properties.XML&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">DeweGetParamStruct_str</span><span class="p">(</span> <span class="s">&quot;BoardID0&quot;</span><span class="p">,</span> <span class="s">&quot;BoardPropertiesFile&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">filename</span><span class="p">));</span>
</pre></div>
</div>
<p>The location can be any arbitrary valid path. Please make sure that the
application has write access to the requested location.</p>
</div>
<div class="section" id="putting-the-board-into-a-defined-initial-state">
<h3>Putting the Board into a defined initial state<a class="headerlink" href="#putting-the-board-into-a-defined-initial-state" title="Permalink to this headline">¶</a></h3>
<p>Requirement: Mandatory – but either one of the following steps is
sufficient</p>
<div class="section" id="board-reset">
<h4>Board-Reset<a class="headerlink" href="#board-reset" title="Permalink to this headline">¶</a></h4>
<p>Requirement: Optional</p>
<p>Loads the ‘default’ settings- as specified in the Boardproperties
XML-File into the logical layer, and immediately apply the logical
settings to the hardware.</p>
<p>This will put the board into a ‘factory’-default state.</p>
</div>
<div class="section" id="load-last-configuration">
<h4>Load Last Configuration<a class="headerlink" href="#load-last-configuration" title="Permalink to this headline">¶</a></h4>
<p>Requirement: Optional</p>
<p>This will load the last used logical configuration into the logical
layer and will immediately apply these settings to the hardware.</p>
<p>If no (valid) last setting is retrievable the default settings will be
loaded and the result will be the same as if performing a Board-Reset.</p>
</div>
<div class="section" id="load-a-specific-configuration">
<h4>Load a Specific Configuration<a class="headerlink" href="#load-a-specific-configuration" title="Permalink to this headline">¶</a></h4>
<p>Requirement: Optional</p>
<p>Any previously stored configuration can be loaded into the logical layer
of the board.</p>
<p>In this case it is the responsibility of the application to trigger the
hardware update for this board.</p>
</div>
</div>
<div class="section" id="setting-up-the-logical-configuration">
<h3>Setting up the Logical Configuration<a class="headerlink" href="#setting-up-the-logical-configuration" title="Permalink to this headline">¶</a></h3>
<p>Requirement: Optional - After setting the board to a defined initial
state this step could be omitted.</p>
<p>During this phase the various necessary parameters to set up the
measurement system are applied to the logical configuration.</p>
<p>These parameters include for example:</p>
<ul class="simple">
<li><p>Desired sample-rate</p></li>
<li><p>Detailed configuration for the various channels:
Like for analogue channels the mode (Voltage, Resistance …) or the
range (1000 Ohm, 15 Volt …)</p></li>
<li><p>Enabling and disabling of single channels for acquisition</p></li>
</ul>
<p>All these settings are applied by using the string-based functions. Each
function call will evaluate the passed information against the
XML-definition for this board, and will indicate to the application if
the information could be processed, was auto-adjusted, or erroneous.</p>
<p>The hardware is not yet affected during this step</p>
</div>
<div class="section" id="applying-the-configuration-to-the-actual-hardware">
<h3>Applying the Configuration to the actual Hardware<a class="headerlink" href="#applying-the-configuration-to-the-actual-hardware" title="Permalink to this headline">¶</a></h3>
<p>Requirement: Mandatory when logical changes have been performed</p>
<p>This will reflect the logical setting down to the actual acquisition
hardware.</p>
</div>
<div class="section" id="setting-up-the-acquisition-meta-information">
<h3>Setting up the Acquisition Meta-Information<a class="headerlink" href="#setting-up-the-acquisition-meta-information" title="Permalink to this headline">¶</a></h3>
<p>Requirement: Mandatory</p>
<p>Setting up information not directly related to the hardware like</p>
<ul class="simple">
<li><p>Desired size of DMA-Buffer in samples</p></li>
</ul>
<p>After this step, the acquisition system is ready to perform the data
acquisition. From this point on, the application can request information
about the DMA-buffer-layout from the API.</p>
<p>This information describes the layout of a single scan, and thus tells
the application where within a single scan the acquired data of a
specific channel can be found.</p>
</div>
<div class="section" id="acquisition-phase">
<h3>Acquisition-Phase<a class="headerlink" href="#acquisition-phase" title="Permalink to this headline">¶</a></h3>
<p>The acquisition phase starts with the command Start Acquisition and ends
with Stop Acquisition.</p>
<p>During this phase the application has to poll the API to obtain the
number of available samples. As the application sets up the
DMA-buffer-size according its own needs. The
application can poll as frequent or infrequent as it sees the fit.</p>
<p>The application just has to make sure to be able to process acquired
data quick enough so that the own selected buffer is never exceeded.</p>
</div>
<div class="section" id="unloading-the-api">
<h3>Unloading the API<a class="headerlink" href="#unloading-the-api" title="Permalink to this headline">¶</a></h3>
<p>Requirement: Mandatory</p>
<p>When finished with using the API, the API has to be unloaded by the
application.</p>
<p>This will trigger several internal operations like storing the current
configuration to be re-used later on.</p>
</div>
</div>
<div class="section" id="preprocessor-defines">
<h2>Preprocessor Defines<a class="headerlink" href="#preprocessor-defines" title="Permalink to this headline">¶</a></h2>
<p>A small set of preprocessor defines can be used to select the correct
API build. These should be set for files that include the dewepxi_load.h
header file.</p>
<div class="section" id="build-x64">
<h3>BUILD_X64<a class="headerlink" href="#build-x64" title="Permalink to this headline">¶</a></h3>
<p>If BUILD_X64 is defined the API file name is set to its 64bit variant.
The DeWePxiLoad function tries to load an API build for 64bit
applications.</p>
</div>
<div class="section" id="build-x86">
<h3>BUILD_X86<a class="headerlink" href="#build-x86" title="Permalink to this headline">¶</a></h3>
<p>This is the default setting. If BUILD_X86 is defined DeWePxiLoad tries
to load an API build for 32bit applications.</p>
</div>
</div>
<div class="section" id="acquisition-ring-buffer">
<h2>Acquisition Ring buffer<a class="headerlink" href="#acquisition-ring-buffer" title="Permalink to this headline">¶</a></h2>
<div class="figure align-center" id="id4">
<img alt="_images/acquisition_ring_buffer.png" src="_images/acquisition_ring_buffer.png" />
<p class="caption"><span class="caption-text">Acquisition ringbuffer</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="scan-and-scan-size">
<h3>Scan and Scan Size<a class="headerlink" href="#scan-and-scan-size" title="Permalink to this headline">¶</a></h3>
<p>One scan is the portion of data that consists of exactly one sample for
each sampled channel on a board.</p>
<p>So if there are 2 analogue channels and 1 counter channel active, the
scan would logically hold three values. (AI0, AI1, CNT0).</p>
<p>The scan-size therefore directly derives from this information. It
describes the memory-consumption of one scan in Bytes. In above example,
when using the AI-channels in 24Bit mode (consuming 32Bit per Sample)
the resulting scan size would be:</p>
<p>ScanSize := sizeof(AI0) + sizeof(AI1) + sizeof(CNT0)</p>
<p>Scansize := 32Bit + 32Bit + 32Bit</p>
<p>Scansize := 4 Byte + 4 Byte + 4 Byte</p>
<p>Scansize := 12 Byte</p>
<p>So one scan would have the size of 12 Byte.</p>
<p>The scan size cannot be directly controlled by the application as it
directly depends on the number and type of activated channels.</p>
<p>Usually the application does not have to know very detailed about one
scan and its layout inherently, as there are ways to get this
information from the API in an abstracted way at runtime.</p>
</div>
<div class="section" id="block-and-block-size">
<h3>Block and Block Size<a class="headerlink" href="#block-and-block-size" title="Permalink to this headline">¶</a></h3>
<p>One block is a collection of <em>n</em> scans.</p>
<p>It is only meant as a logical unit and does not directly influence the
driver in any way. Usually it is set up in accordance with the
polling-interval of the application.</p>
<p>The block-size can be set to any arbitrary value &gt; 0. A standard use
case would set it to SampleRate * pollingIntervall. For Example:</p>
<p>BlockSize := SampleRate * pollingIntervall</p>
<p>BlockSize := 2000 SPS * 0.1 sec</p>
<p>BlockSize := 200</p>
<p>This has to be set by the application.</p>
</div>
<div class="section" id="block-count">
<h3>Block Count<a class="headerlink" href="#block-count" title="Permalink to this headline">¶</a></h3>
<p>This defines how many blocks the buffer shall be able to hold. This
allows the application to control how big the backlog of data shall be
and thus how much time the application may spend with tasks not related
to the acquisition – so that peaks in computation times won’t lead to
lost acquisition data.</p>
<p>It can be set to any value &gt; 0, and is only limited by the total
available memory.</p>
<p>For example:</p>
<p>BlockCount := 50</p>
<p>This has to be setup by the application.</p>
</div>
<div class="section" id="total-buffer-size">
<h3>Total Buffer Size<a class="headerlink" href="#total-buffer-size" title="Permalink to this headline">¶</a></h3>
<p>The total buffer size is calculated based on the above described
information.</p>
<p>Buffersize := ScanSize * BlockSize * BlockCount</p>
<p>In our example:</p>
<p>BufferSize := 12 Bytes * 200 * 50</p>
<p>BufferSize := 12 Bytes * 10000</p>
<p>Buffersize := 12000 Bytes</p>
</div>
</div>
<div class="section" id="synchronous-data-channels">
<h2>Synchronous Data Channels<a class="headerlink" href="#synchronous-data-channels" title="Permalink to this headline">¶</a></h2>
<p>Each sampling period produces one sample for each channel and consumes
“Scan Size” amount of data in the buffer. There are currently three
kinds of synchronous data in the buffer: analog channel samples, counter
channel samples and digital channel samples.</p>
<p>The driver itself maintains a separate read- and write-pointer into this
buffer. So the hardware can add new samples independent of the
applications data-processing.</p>
<p>The driver will notify the application with an error-code if a
buffer-overrun occurs. That is, if the application processes data too
slow, so that the new samples have already overwritten unprocessed old
ones.</p>
<p>The application then can freely decide how to handle this error case.</p>
<div class="section" id="buffer-setup-and-buffer-ownership">
<h3>Buffer Setup and Buffer Ownership<a class="headerlink" href="#buffer-setup-and-buffer-ownership" title="Permalink to this headline">¶</a></h3>
<p>The buffer itself is completely maintained inside the API – so the
applications do not have to bother with allocation and de-allocation
issues, which usually come with having a buffer.</p>
<p>However – to allow the application a fine granulated control over the
buffer, it is able and obligated to indicate to the API the desired size
of the buffer in terms of logical units, by using the integer-based
functions. The application decides, how many scans one block shall hold,
and how many blocks shall be allocated. The actual size in bytes is then
calculated by the API and the buffer is allocated.</p>
</div>
<div class="section" id="buffer-readout-from-application-point-of-view">
<h3>Buffer Readout from Application Point of View<a class="headerlink" href="#buffer-readout-from-application-point-of-view" title="Permalink to this headline">¶</a></h3>
<p>The ring-buffer is exposed to the application by providing the related
pointer information.</p>
<p>The API will provide:</p>
<ul class="simple">
<li><p>Start-pointer of the ring buffer</p></li>
<li><p>End-Pointer of the ring buffer</p></li>
<li><p>Pointer to the first unprocessed scan</p></li>
</ul>
<p>Together with the information how many unprocessed samples are available
the application iterates directly over the ring buffer.</p>
<p>This approach allows a minimal internal overhead on data-access.</p>
</div>
<div class="section" id="scan-layout">
<h3>Scan Layout<a class="headerlink" href="#scan-layout" title="Permalink to this headline">¶</a></h3>
<p>As mentioned before a scan is the portion of data
containing exactly one sample per used channel. Without knowledge about
its internal layout, this would just be a binary stream with arbitrary
length.</p>
<p>But the application does not need to know implicitly about the layout of
the data. This would be undesirable, as the layout may change with
coming driver versions or coming hardware. For example, when a new type
of synchronous data will be added, inherent hardcoded knowledge within
the application would immediately break the data-readout mechanism of
the application.</p>
<p>So after setting up the acquisition environment, the API can be queried
about the layout.</p>
<p>The detailed layout-information will be returned as an XML-string.</p>
<div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption"><span class="caption-text">BoardProperties - ScanDescriptor Example</span><a class="headerlink" href="#id5" title="Permalink to this code">¶</a></div>
<div class="highlight-XML notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;ScanDescriptor&gt;</span>
    <span class="nt">&lt;BoardId0&gt;</span>
        <span class="nt">&lt;ScanDescription</span> <span class="na">version=</span><span class="s">&quot;2&quot;</span> <span class="na">scan_size=</span><span class="s">&quot;96&quot;</span> <span class="na">byte_order=</span><span class="s">&quot;little_endian&quot;</span> <span class="na">unit=</span><span class="s">&quot;bit&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Channel</span> <span class="na">type=</span><span class="s">&quot;Analog&quot;</span> <span class="na">index=</span><span class="s">&quot;3&quot;</span> <span class="na">name=</span><span class="s">&quot;AI3&quot;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;Sample</span> <span class="na">offset=</span><span class="s">&quot;32&quot;</span> <span class="na">size=</span><span class="s">&quot;24&quot;</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/Channel&gt;</span>
        <span class="nt">&lt;/ScanDescriptor&gt;</span>
    <span class="nt">&lt;/BoardId0&gt;</span>
<span class="nt">&lt;/ScanDescriptor&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="scan-descriptor-structure">
<h3>Scan Descriptor Structure<a class="headerlink" href="#scan-descriptor-structure" title="Permalink to this headline">¶</a></h3>
<p>The following API string command returns the scan information for a
specific Board:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">DeweGetParamStruct_str</span><span class="p">(</span> <span class="s">&quot;BoardId0&quot;</span><span class="p">,</span> <span class="s">&quot;ScanDescriptor_V2&quot;</span><span class="p">,</span> <span class="n">Buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Buf</span><span class="p">));</span>
</pre></div>
</div>
<p>The returned XML document correlates with the following hierarchy:</p>
<ol class="arabic simple">
<li><p>&lt;ScanDescriptor&gt; : XML Element. Max. Occurrences: 1.</p></li>
<li><p>&lt;BoardID0&gt; : XML Element. Max. Occurrences: 1.</p></li>
<li><p>&lt;ScanDescription&gt; : XML Element. Max. Occurrences: 1.</p></li>
<li><p>&lt;Channel&gt; : XML Element. Max. Occurrences: Unbounded.</p></li>
<li><p>&lt;Sample&gt; : XML Element. Max. Occurrences: Unbounded.</p></li>
</ol>
<p>Please be aware that the scan descriptor annotates only the enabled
channels for a specific Board. In case no channel is enabled, the API
returns an empty scan descriptor with “scan_size” set to the value 0.</p>
<p>The API considers disabled channels and therefore the returned
“scan_size” and “offsets” are being returned accordingly.</p>
<p>The following list depicts all possible XML Elements and their XML
attributes and values of the returned scan descriptor XML document:</p>
<ul>
<li><p>ScanDescriptor</p>
<blockquote>
<div><ul class="simple">
<li><p>Attributes: None</p></li>
<li><p>Note: An empty element. Always “ScanDescriptor”.</p></li>
<li><p>Value: None</p></li>
</ul>
</div></blockquote>
</li>
<li><p>BoardID</p>
<blockquote>
<div><ul class="simple">
<li><p>Attributes: None</p></li>
<li><p>Note: An empty element, same as the api cll target. Eg “BoardID0”.</p></li>
<li><p>Value: None</p></li>
</ul>
</div></blockquote>
</li>
<li><p>ScanDescription</p>
<blockquote>
<div><ul>
<li><p>Attributes: None</p></li>
<li><p>Note: Describes the scan for the requested board.</p></li>
<li><p>Value:</p>
<blockquote>
<div><ul>
<li><p>version:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: “1” or “2”</p></li>
<li><p>Note: Scan descriptor’s document version. For this API version always “2” when requested with “ScanDescriptor_V2”. Requesting “ScanDescriptor” will return version “1”.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>scan_size:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: integer</p></li>
<li><p>Note: The size of the scan expressed in the unit, described via the attribute “unit”.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>byte_order:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: little_endian</p></li>
<li><p>Note: Describes the byte order of the scan. Only little endian is supported with this API version.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>unit:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: bit</p></li>
<li><p>Note: Describes the unit of “scan_size” attribute for the children attributes “offset” and “size”. Always “bit” for this API version.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p>Channel</p>
<blockquote>
<div><ul>
<li><p>Attributes: None</p></li>
<li><p>Note:</p></li>
<li><p>Value:</p>
<blockquote>
<div><ul>
<li><p>index:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: integer</p></li>
<li><p>Note: The channel index on the specific board.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>name:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: string</p></li>
<li><p>Note: e.g. name=”AI1”. The composite string “BoardID1/AI1” can be used as target for further API calls.
For further details regarding the API targets please refer to the dedicated chapter.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>type:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: string “Analog”, “Counter”, “Discrete”, “BoardCounter”</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Note: Discrete channels describe digital channels.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Sample</p>
<blockquote>
<div><ul>
<li><p>Attributes: None</p></li>
<li><p>Note: Describes an available sample of a specific channel.</p></li>
<li><p>Value:</p>
<blockquote>
<div><ul>
<li><p>offset:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: integer</p></li>
<li><p>Note: The sample offset within the whole scan. The unit is according the attribute “unit” of the “ScanDescription” element.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>size:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: integer</p></li>
<li><p>Note: The sample size. The unit is according the attribute “unit” of the “ScanDescription” element.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>subChannel:</p>
<blockquote>
<div><ul class="simple">
<li><p>Value: string “Counter/Sub”, “BoardCounter/Sub”</p></li>
<li><p>Note: Optional attribute. Only returned if a subchannel is enabled e.g. “BoardCounter/Sub”</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When requesting a scan descriptor with command “ScanDescriptor” (Version
1), some newer board may not be able to return a valid scan descriptor
for analog 24bit channels. Therefore, always use “ScanDescriptor_V2”.</p>
</div>
</div>
</div>
<div class="section" id="asynchronous-data-channels">
<h2>Asynchronous Data channels<a class="headerlink" href="#asynchronous-data-channels" title="Permalink to this headline">¶</a></h2>
<p>Compared to the synchronous data channels, asynchronous data channels
have a considerably lower data rate. This is true even if many
asynchronous channels are used simultaneously.</p>
<p>Also unlike synchronous channels there is an expected amount of incoming
data per time-unit. Asynchronous messages can be several seconds apart
from each other or even within the same millisecond. So the data influx
is non-deterministic.</p>
<p>This fact is exploited to reduce buffer-maintenance-overhead within the
driver and to make use of a more suitable DMA approach for this kind of
non-deterministic data.</p>
<p>Unlike the acquisition buffer for synchronous data, that is maintained
dynamically depending on several input parameters, the buffer for
asynchronous data is static and allocated with a reasonably big size.
(Default is 64kB).</p>
<div class="section" id="types-of-supported-asynchronous-channels">
<h3>Types of supported Asynchronous Channels<a class="headerlink" href="#types-of-supported-asynchronous-channels" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>CAN channels</p></li>
<li><p>UART (RS485) channels</p></li>
</ul>
</div>
<div class="section" id="acquisition-of-asynchronous-channels">
<h3>Acquisition of Asynchronous Channels<a class="headerlink" href="#acquisition-of-asynchronous-channels" title="Permalink to this headline">¶</a></h3>
<p>The kernel-mode driver queries the hardware in a configurable time
interval if asynchronous data is available in the board hardware
buffers.</p>
<p>If a certain threshold of data is exceeded a DMA transfer is started.</p>
<p>As asynchronous data is already time stamped on TRION hardware, even on
sub-sample-count basis, the minimal delay introduced by this approach
has no negative impact on correlation between asynchronous and
synchronous data.</p>
</div>
<div class="section" id="id1">
<h3>Buffer Setup and Buffer Ownership<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>The buffer itself is completely maintained by the API and of
fixed size. The application has no direct influence on the existence or
the size of the buffer itself.</p>
</div>
<div class="section" id="id2">
<h3>Buffer Readout from Application Point of View<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>The buffer is not directly exposed to the application.</p>
<p>To allow data access on acquired asynchronous data a specialized set of
non-blocking function is available. Each set of functions is specialized
to a specific type of asynchronous data.</p>
<p>For standard formats like for example CAN, definitions and functions to
retrieve already decoded frames are available.</p>
<p>To allow the application for more granulated control in data-handling
also functions to retrieve undecoded frames (raw frames) are available.</p>
</div>
</div>
<div class="section" id="directories-and-files">
<h2>Directories and Files<a class="headerlink" href="#directories-and-files" title="Permalink to this headline">¶</a></h2>
<p>Base directories:</p>
<p>Windows:</p>
<ul class="simple">
<li><p>C:\Users\All Users\Documents\Dewetron\Trion</p></li>
</ul>
<p>Linux:</p>
<ul class="simple">
<li><p>/var/opt/Dewetron/Trion</p></li>
</ul>
<div class="section" id="dewetron-trion">
<h3>Dewetron/Trion<a class="headerlink" href="#dewetron-trion" title="Permalink to this headline">¶</a></h3>
<p>Contains the file dwpxi_api_config.xml that is modified by the Dewetron
EXPLORER application and read by TRION API during DeWeDriverInit().</p>
<p>This is the way how API simulation is configured.</p>
</div>
<div class="section" id="dewetron-trion-systemxml">
<h3>Dewetron/Trion/SystemXML<a class="headerlink" href="#dewetron-trion-systemxml" title="Permalink to this headline">¶</a></h3>
<p>Contains the BoardX_Properties.xml files for each found TRION board.
Other files are initialization artefacts and can be ignored.</p>
</div>
<div class="section" id="dewetron-trion-logfiles">
<h3>Dewetron/Trion/LogFiles<a class="headerlink" href="#dewetron-trion-logfiles" title="Permalink to this headline">¶</a></h3>
<p>Contains API specific temporary and log files.</p>
</div>
<div class="section" id="dewetron-trion-backup">
<h3>Dewetron/Trion/Backup<a class="headerlink" href="#dewetron-trion-backup" title="Permalink to this headline">¶</a></h3>
<p>Contains EEPROM backup files for each board found.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="trion_api_xml.html" class="btn btn-neutral float-right" title="TRION API XML Documents" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="trion_api_c_interface.html" class="btn btn-neutral float-left" title="TRION API C Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, DEWETRON GmbH

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>